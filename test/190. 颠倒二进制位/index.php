<?php

/**
颠倒给定的 32 位无符号整数的二进制位。

 

示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
class Solution {
    /**

    参考：http://www.hishenyi.com/archives/1356
    1、首先要有2个变量，
    1）临时变量叫做  $xxoo , 初始值是0（十进制），二进制也就是00000000
    2）原始值 变量，叫做$shit , 就是要做处理的 00000101

    2、3个步骤
    1) 把$xxoo 左移 一位
    2) 判断 $shit的二进制值最后一位 是不是1，如果是 ，则给$xxoo的十进制值加1 ，这个很重要 看成二进制就是把00000000 变成 00000001
    否则 $xxoo 初始值是00000000， 这个进行移位移个屁啊。。。 都是零
    那么 tmd怎么判断二进制最后一位是不是1？  你要通过截取字符串或正则判断 算你牛逼（不是不可以哦）

    答：只要把原值和 1（也就是00000001） 进行 逻辑与操作 （1&1 才是1 ，1&0 或0&1 一律是0）

    3） 接下来把$shit 右移 1位  ，如原来是 00000101 ,移动后变成了 00000010

    (也就是说$xxoo和shit同时移，一个左一个右，当shit最后一位是1的时候能被我们判断到，于是给$xxoo的末位也置为1，这样就能实现xxoo和shit既同步又相反)

    上面的过程反复执行8 次，就能得到10100000
     */

    function reverseBits1($n) {
        $xxoo = 0;
        for ($i = 0; $i < 32; $i++) {
            $xxoo = $xxoo << 1;

            if (($n & 1) == 1) {
                $xxoo++;
            }

            $n = $n >> 1;

        }
    return $xxoo;
    }
}
$soluition = new Solution();
var_dump($soluition->reverseBits(11111111111111111111111111111101));
